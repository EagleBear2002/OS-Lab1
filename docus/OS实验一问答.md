# OS实验一问答

### 什么是复杂指令集（RISC）？什么是精简指令集（CISC）？80x86采⽤的是哪种？

CISC对CPU逻辑电路的设计要求高，简化了对编译器的要求，但是带来了CPU成本和功耗的增加。
		RISC通过多条简单指令拼凑一个复杂功能，对编译器优化要求高，但是功耗低，CPU设计简单，主要用在端侧。

CISC指令长度不固定，指令较多，这将导致指令切割复杂，通常需要切割未多个微操作码，然后执行计算。
		RISC指令长度固定，指令较少，指令码切割简单，这将更容易并行化，执行效率高。

80x86采用的是复杂指令集

### 什么是⼩端存储？什么是⼤端存储？80x86采⽤的是哪种？

"大端"和"小端"表示多字节值的哪一端存储在该值的起始地址处;小端存储在起始地址处,即是小端字节序;大端存储在起始地址处,即是大端字节序。
		大端存储模式：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；
		小端存储模式：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；

80x86是小端存储

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525162747150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NjU5Mg==,size_16,color_FFFFFF,t_70)

### 8086有哪5类寄存器？请分别举例说明其作⽤。

1. 4个16位的通用寄存器（AX、BX、CX、DX），可以存放16位的操作数，也可分为8个8位的寄存器（AL、AH；BL、BH；CL、CH；DL、DH）来使用。
2. 两个16位的指针寄存器SP和BP，其中SP是堆栈指针寄存器，由它和堆栈段寄存器SS一起来确定堆栈在内存中的位臵；BP是基数指针寄存器，通常用于存放基地址。
3. 两个16位的变址寄存器SI和DI，其中SI是源变址寄存器，DI是目的变址寄存器，都用于指令的变址寻址方式。
4. IP、标志寄存器是两个16位控制寄存器，其中IP是指令指针寄存器，用来控制CPU的指令执行顺序，它和代码段寄存器CS一起可以确定当前所要取的指令的内存地址。标志寄存器的内容被称为处理器状态字PSW，用来存放8086CPU在工作过程中的状态。
5. 4个16位段寄存器，即代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS和附加段寄存器ES。这些段寄存器的内容与有效的地址偏移量一起，可确定内存的物理地址。

### 有哪些段寄存器，它们的作⽤是什么？

系统中共有4个16位段寄存器，即代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS和附加段寄存器ES。这些段寄存器的内容与有效的地址偏移量一起，可确定内存的物理地址。通常CS划定并控制程序区，DS和ES控制数据区，SS控制堆栈区。

### 什么是寻址？8086有哪些寻址⽅式？

*寻址*方式是指寻找指令或操作数有效地址的方式,也就是指确定本条指令的数据地址,以及下一条将要执行的指令地址的方式。

所谓寻址就是根据计算机设计好的寻址方式来找到需要的数据和指令。（这里没有找到具体的解释，这是我编的）

8086有七种寻址方式：立即数寻址、寄存器寻址、直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址、相对基址变址寻址。

### 什么是直接寻址？直接寻址的缺点是什么？

直接寻址是一种基本的寻址方法，其特点是:在指令格式的地址的字段中直接指出操作数在内存的地址。由于操作数的地址直接给出而不需要经过某种变换，所以称这种寻址方式为直接寻址方式。

指令字的形式地址地址A就是操作数的真实地址EA，即EA=A。直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作的地址；缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

### 主程序与⼦程序之间如何传递参数？你的实验代码中在哪⾥体现的？

1. 利用寄存器传递参数：利用寄存器传递参数就是把参数放在约定的寄存器中，这种方法的优点是实行啊你个简单和调用方便，但是由于寄存器的个数有限，并且寄存器往往还需要存放其他数据因此只适合传递参数比较少的情况。
2. 利用约定的存储单元传递参数：在传递参数较多的情况下，可以利用约定的内存变量来传递参数，这种方法的优点是子程序要处理的数据或送出的结果都有独立的存储单元，编写程序的时候不容易出错。
3. 利用堆栈传递参数：如果使用堆栈传递入口参数，那么主程序在调用子程序之前，把需要传递的参数依次压入堆栈，子程序从堆栈中取入口参数，如果使用堆栈传递出口参数，那么子程序在返回前，把需要返回的参数存入堆栈，主程序在堆栈中取出口参数即可。利用堆栈传递参数可以不用占用寄存器，也无需额外使用存储单元，由于参数和子程序的返回地址混在一起，有事还要考虑保护寄存器，所以比较复杂，通常利用堆栈传递参数的入口参数，而利用寄存器传递出口参数。
4. 利用CALL后续区传递参数：CALL后续曲是指位于CALL指令后的存储区，主程序在调用子程序之前，把入口参数存入CALL指令后面的存储区，子程序根据保存在堆栈中的返回地址找到入口参数，这种传递参数的方法称为CALL后续传递参数法，由于这种方法吧数据和代码混在一起，在x86系列中使用的不多

### 如何处理输⼊和输出？你的代码中在哪⾥体现的？

没找到具体答案，自己编吧

### 请分别简述 MOV 指令和 LEA 指令的⽤法和作⽤。

传送指令MOV（Move）表示把一个字节、字或双字的操作数从源位置传送到目的位置，源操作数的内容不变。

lea指令实际上仅仅做寄存器和立即数的计算，并不真实访问内存，其载入的内存地址，仅仅是一个数值，并不需要对该内存地址有访问权限。

lea:加载有效地址，一般都是从内存里面取出地址传递给寄存器，相当于C语言里面的取地址符号&。mov就是将一个值（这个值可能在内存，也可能在寄存器里面）传递给另外一个容器（ 可以是寄存器，可以是内存），当然传递还有许多限制，在这就不一一赘述。

### 解释 boot.asm ⽂件中 org 07c00h 的作⽤。

org 07c00h的作用：告诉汇编器，当前这段代码会放在07c00h处。所以，如果之后遇到需要绝对寻址的指令，那么绝对地址就是07c00h加上相对地址。在第一行加上org 07c00h只是让编译器从相对地址07c00h处开始编译第一条指令，相对地址被编译加载后就正好和绝对地址吻合。

### 解释 boot.asm ⽂件中 times 510-(\$-$$) db 0 的作⽤。

\$-$$可能会经常被用到，它表示本行距离程序开始处的相对距离。times 510-($-$)  db  0  的意思就是将0这个字节重复510-($-$)遍，直到程序有510B为止。这样，加上结束标志0XAA55占用2B，恰好是512B。软盘、硬盘的最小粒度为扇区，每个扇区固定为512字节，所以我们要把程序加满到能填充一个扇区。

### 解释 bochsrc 中各参数的含义。

display_library：Bochs使⽤的GUI库 

megs：虚拟机内存⼤⼩ (MB)

floppya：虚拟机外设，软盘为a.img⽂件

boot：虚拟机启动⽅式，从软盘启动

### boot.bin 应该放在软盘的哪⼀个扇区？为什么？

boot.bin需要放在软盘的第一个扇区。因为BIOS程序检查软盘0面0磁道1扇区，如果扇区以0xaa55结束，则认定为引导扇区，将其512字节的数据加载到内存的07c00处，然后设置PC，跳到内存07c00处开始执行代码。

### Loader的作⽤有哪些？

1. 跳⼊保护模式：最开始的x86处理器16位，寄存器⽤ax, bx等表示，称为实模式。后来扩充成32位，eax，ebx等，为了向前兼容，提出了保护模式。必须从实模式跳转到保护模式，才能访问1M以上的内存。

2. 启动内存分⻚。

3. 从kernel.bin中读取内核，并放⼊内存，然后跳转到内核所在的开始地址，运⾏内核 。跟boot类似，使⽤汇编直接在软盘下搜索kernel.bin但是，不能把整个kernel.bin放在内存，⽽是要以ELF⽂件的格式读取并提取代码。